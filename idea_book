21:46 < caleb-> gogonkt: 在写自己的 ime?
21:46 < letoh> .cin 一般就是 table 吧... 當然，可以用 hash table 來改進查詢的速度
21:47 < caleb-> gogonkt: 可以先看看 gtk 自带的简单 immodule
21:47 < caleb-> gogonkt: 或者研究下 gcin 的 IMdkit
21:47 < caleb-> gogonkt: gcin 和 scim 用的 IMdkit 基本一模一样
21:34 < gogonkt> 先力氣放在ime engine上
Sun Sep 27 21:53:53 HKT 2009
12:57 < gogonkt> 把table.cin 轉成 forth programe 就完成了
12:58 < gogonkt> :table-abc ." 就 完 成 了" ;
13:00 < gogonkt> 然後，: parser ( string1 -- font ) $table-name calls ;
13:00 < gogonkt> 這樣，stack 里就有了 ." 就 完 成 了" 這幾個字
2009年 09月 28日 星期一 13:02:43 HKT
15:38 < gogonkt> howto dynamic calls a word? for example, string ." table-foo", call word table-foo 
15:39 < gogonkt> I want call word table-foo, dynamic
15:46 < I440r> im not sure im following you
15:46 < I440r> you want to call a word whose name is expressed between the quotes?
15:47 < I440r> ans has evaluate. horrible word
15:47 < I440r>  ," blah" evaluate
15:47 < gogonkt> yes
15:47 < I440r> in the above instance the word blah is executed
15:47 < I440r> : foo " blah" evaluate ; or something
15:47 < I440r> which i say is MORONIC
15:47 < I440r> : foo blah ;
15:47 < I440r> dun
15:48 < I440r> if you knew the name of the word you wanted to execute at compile time you should have compiled its XT
15:48 < I440r> not a string with its name
15:48 < I440r> if you dont know the name of the word until RUN time thats different
15:49 < gogonkt> I wanted execute at runtime
15:49 < I440r> ok it will be executed at run time
15:49 < I440r> what you want to do is searchj for the word name at run time (something taht should be done at compile time if 
               you can)
15:49 < I440r> then execute its xt
15:50 < I440r> if you know the NAME of a word AT compile time. COMPILE ITS XT lol
15:50 < I440r> dont compile a string with its name in it and then evaluate taht string
15:50 < I440r> thats sillyness
15:50 < I440r> but if you want to execute a word whose name you dont know at compile time.... thats different
15:50 < gogonkt> word-name in 'stack' and want execute word named 'word-name'
15:51 < I440r> for instance you might have a game where the user can input different strings.  the things the user is inputting 
               is a WORD name
15:51 < I440r> " north [enter]"
17:16 < ASau> gogonkt: where possible use ['] ' EXECUTE instead of EVALUATE
17:17 < gogonkt> what is diference between?
17:18 < ASau> EVALUATE uses dictionary search, while EXECUTE executes already resolved word.
2009年 09月 28日 星期一 17:27:35 HKT
2009年 10月 02日 星期五 21:06:44 HKT
21:05 < gogonkt> linux 的換行符是 crlf 麼?
21:05 <@sleeve> 错
21:05 <@sleeve> 只有一个
21:05 <@sleeve> lf
20:37 < gogonkt> 查找對應的 編碼<=>字/詞
20:41 < gogonkt> 對了，文件是一行行，讀進來也是一行行的哦
20:48 < gogonkt> foxes: 我想直接從plan text 讀進來操作
20:49 < gogonkt> 碼表處理就簡單更多
2009年 10月 02日 星期五 21:44:57 HKT
" pns 你 ix 我 pal 他 iwn 這 qe 里" pad place
pad count type
2009年 10月 02日 星期五 23:00:55 HKT
ok> pad count " ix" search
ok> drop type
ix 我 pal 他 iwn 這 qe 里
2009年 10月 02日 星期五 23:25:18 HKT
01:15 < gogonkt> i want cut first word out
01:15 < tathi> take a look at skip and scan if your Forth has them
01:15 < gogonkt> skip, scan ok
01:16 < ASau> gogonkt: 2dup bl scan nip /string
01:19 < ASau> gogonkt: scan, skip and /string are your friends.
2009年 10月 03日 星期六 01:29:27 HKT
" 你 ix 我 pal 他 iwn 這 qe 里" 2dup bl /char .s cr nip - .s cr type
2009年 10月 03日 星期六 02:13:21 HKT
Sat Oct  3 21:15:48 HKT 2009
: (testkey) ( -- )
repeat
ekey dup emit 'Q <> 
 while ;
Sat Oct  3 21:17:02 HKT 2009
23:11 < gogonkt> recursion and loops which is better in forth?
23:12 < tathi> It depends. :)
23:14 < tathi> I tend to use loops more than recursion.
23:14 < gogonkt> mh
23:15 < I440r> unless your doing something moronic like an ackerman function itterative methods are generally faster and WAY 
               simpler than recursive methods
23:16 < gogonkt> : cleave ." separates" ;
23:16 < gogonkt> : cleave ." joins " prior cleave ;
23:18 < I440r> : fib 0 1 rot 1+1 do tuck + loop nip ;
23:18 < I440r> forgot to give it a name
23:18 < tathi> Heh.
23:18 < tathi> And here I was trying to figure out if it actually did return 0.
23:19 < I440r> lol
23:19 < I440r> if you write that in the more traditional recusive way it will recurse on itself one hundred and fourteen 
               MILLION times to calculate the 40th fib
23:27 < tathi> A direct translation to recursion looks like this:
23:27 < tathi> : (fib)  >r  tuck +  r> 1- dup if recurse then ;
23:27 < tathi> : fib 0 1 rot (fib) drop nip ;
Sun Oct  4 01:35:20 HKT 2009
